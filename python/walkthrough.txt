GAME INIT

Each player chooses a role and an initial location.

All players have 1 research slot, 1 project slot and 1 policy slot.

The can contribute to research, projects and policies from any other
player but not in the turn the project, policy or research is started.


TURN

  ENGAGE PHASE

      for each player in parallel, without knowing what the other players do, they do, in order:

      MOVING

            if turn is not the first

                Decision NEW_LOC: Player chooses a new location from all the locations in the board

      DRAWING POWER

            The player draws a number of power units equals to
                1 +  
                (1 if the location in the board where the player has moved has a '!' associated with it, 0 otherwise) + 
                (1 if the player role has a resource of '!', 0 otherwise)

      DRAWING MONEY

            The player draws a number of money units equals to
                5 - numer of crisis in category 'ECONOMIC' + 2 * (
                  (1 if the location in the board where the player has moved has a '$' associated with it, 0 otherwise) + 
                  (1 if the player role has a resource of '$', 0 otherwise)
                )

      DRAWING CARDS

            The player has access to potentially three piles to draw from: two piles from the card suits associated with the player's role plus a card suit associated with the player's current location. We call these piles the 'accessible piles'

            If the number of accessible piles is 2, then the player draws one card from each.

            If the number of accessible piles is 3, then the player makes two decisions:

                Decision PILE_DRAW: decide from which of the 3 piles to draw a card
                Decision PILE_DRAW: decide from which of the remaining 2 piles to draw a card


      CRISIS RISING

            A crisis chip to the turn is added for each player



  ACTIVATE PHASE

     Once the engage phase is completed by all players, the players see where in the board the other players are.

     Then activate phase starts, again, parallel blind. 

     The following actions are recorded separately by each player as part of this phase:
    
     START_PROJECT  = The player started a specific project.
     SUCCESS_SKILL  = The player performed a successful skill check for a given project, with a specific roll value against a specific card value.
     FAILED_SKILL   = The player failed a skill check for a given project, with a specific roll value against a specific card value.
     START_POLICY   = The player started a specific policy.
     EMPOWER_POLICY = The player added a specific number of power units to empower a policy.
     START_RESEARCH = The player started researching a specific technology.
     SKILL_RESEARCH = The player contributed a skill card to a specific technology being researched.
     FUND_RESEARCH  = The player contributed a money unit to a specific technology being researched.

     Each player performs the actions described

     ATTEMPTING PROJECTS

            If the player has project slots available, the player has to decide whether to start a project of a given type or not start any project:

            Decision START_PROJECT: Choose between the two types of projects (base or remove-tradeoff) or nothing to not start a project this turn.

            If the player picked a project type to start, then the player decides which category of problem they want to fix with their project:

                Decision START_PROJECT_FIX_CAT: Choose among the six categories of problems.

                With the chosen category, the player can choose which problem to fix:

                Decision START_PROJECT_FIX_NODE: choose among all the problems in that category

                If the player has chosen to start a base project, the player needs to choose also a trade-off problem in the trade-off category for the chosen category (based on the table):

        ( Graph.ENVIRONMENTAL,          Graph.LIVING_STANDARDS,	'C', 'D' ),
        ( Graph.LIVING_STANDARDS,	Graph.CLASS,	        'H', 'C' ),
        ( Graph.SOCIAL,	                Graph.INDUSTRIAL,	'H', 'D' ),
        ( Graph.CLASS,	                Graph.SOCIAL,	        'H', 'S' ),
        ( Graph.ECONOMIC,	        Graph.ENVIRONMENTAL,	'S', 'D' ),
        ( Graph.INDUSTRIAL,	        Graph.ECONOMIC,	        'S', 'C' ),


                      Decision START_PROJECT_TRIGGER_NODE: Choose from all the problems in the trade-off category

                With the above decisions, the new project is created, added to the player project slot.

                Phase action recorded: START_PROJECT (project)
            
            After potentially creating a new project, the player can decide to play cards for any projects.

            That includes projects existing at the beginning of the phase or projects the player has created this turn (but not projects created by other players this phase).

            The player is then presented with a choice of playing a particular card for a particular project or nothing to stop playing cards.

            While the player does not choose to play nothing and there are cards that can be played against available projects:
            
                    Decision PLAY_CARD: Choose a card and a project to play it for

                    If the card is a joker, it automatically succeeds.

                    If the card is not a joker, the value of the card is its face value or 10 if the card is Ace, Knight, Queen or King.

                         To the value of the card, if the table has researched a base technology for the skill, the value is increased by 1. The value cannot exceed 11.

                         To the value of the card, if the table has researched an expanded technology for the skill, the value is further increased by 2. The value cannot exceed 11.
                         
                         To this value, the player can decide to use money units (if the player has them) as consultant fees to further increase its value:
                             Decision CONSULTANT: Choose between 0 to the minimum between the amount of money the player has and the number that will take the current value to 11.

                         The final value to roll against (card value + research boost + consultant fees) is then rolled with 2D6:

                         Roll Skill Check: 2D6

                         If the roll is less or equal to the value, the check is successful:

                            Phase action recorded: SUCCESS_SKILL (project, card, value, roll)

                         If the roll is greater than value, the check failed:
                             
                            Phase action recorded: FAILED_SKILL (project, card, value, roll)

                         If the roll equals 12, a crisis chip is added to the turn, immediately.

                         The cards used are returned to the drawpiles, with the jokers being returned to the pile of the suit they were used in replacement (not necessarily the suit they were taken from).

     PASSING POLICY

            If the player has policy slots available, the player has to decide whether to start a policy of a given type or not start any policy:

            Decision START_POLICY: Choose between the three types of policies (remove-tradeoff, protect-category or protect-any) or nothing to not start a policy this turn.

            If the player picked a policy type to start, then the player decides which category of problem they want to fix with their policy:

                Decision START_POLICY_FIX_CAT: Choose among the six categories of problems.

                With the chosen category, the player can choose which problem to fix:

                Decision START_POLICY_FIX_NODE: choose among all the problems in that category

                If the player has chosen a protect-category type of policy, the player can 

                      Decision START_POLICY_PROTECT_NODE: Choose a problem in that category to protect (it can be the same one the policy is also fixing)
                Besides, if the player has chosen a protect-any type of policy, the player also chooses an extra problem to protect:

                       Decision START_POLICY_PROTECT_NODE: Choose a problem in any category to protect

                With the above decisions, the new policy is created, added to the player policy slot.

                Phase action recorded: START_POLICY (policy)

            After potentially creating a new policy, the player can decide to use power units to pass power for any policy in the table at the beginning of the turn or a policy the player has created this turn (but not policies created by other players this phase). Policies are divided between policies in progress (need many power units) and passed policies (that need one power unit for several turns until they pass).

            The player is then presented with a choice of empowering different policies.

            While the player has power units and policies to choose from:

                Decision POLICY_TO_EMPOWER: Choose among policies that the player has not yet empowered or nothing to stop empowering policies

                If the player has chosen a policy to empower:

                     If the policy has passed or the policy is in progress and only missing one unit, then the player will contribute one power unit to it.

                     Otherwise the player has to choose how many power units to use to empower the policy:
                     
                            Decision POWER_AMOUNT: Choose a number between 1 and the minimum between the total number of power units the player has and the power units needed by the policy.

                     Phase action recorded: EMPOWER_POLICY (policy, power units)

     DOING RESEARCH
                                      ],
            # research
            start = False
            if self.state.players[self.state.player].available_research_slots():
                boundary = self.phase_start_state.tech.research_boundary()
                chosen_tech = self.players[self.state.player].pick(
                    Player.START_RESEARCH,
                    sorted(list(map(lambda x:x.name, boundary))) + [ None ],
                    rand, self.state.players[self.state.player], self.phase_start_state)
                self.log.append( { 'phase' : phase,
                                   'step' : Game.STEPS_PER_PHASE[phase][2],
                                   'target' : chosen_tech,
                                   'memo' : Game.L_START_RESEARCH,
                                   'state' : self.state.to_json() } )
                start = chosen_tech is not None
                if start:
                    tech = self.state.tech[chosen_tech]['tech']
                    self.state.tech.player_starts(tech, self.state.player, self.state.turn)
                    self.state.players[self.state.player].tech.append(tech.name)
                    self.phase_actions.append( ( self.state.player, Game.A_START_RESEARCH, tech ) )
                    started_tech = tech

            researching = self.state.tech.techs_for_status(TechTreeState.IN_PROGRESS)
            if start:
                researching.append(started_tech)

            ## cards for research
            cards_for_tech = list()
            for idx, card in enumerate(self.state.players[self.state.player].cards):
                for tech in researching:
                    if card[0] == tech.suit or card[1] == 14:
                        cards_for_tech.append( (tech.name, card, idx, tech.suit) )
            cards_for_tech = sorted(cards_for_tech)
                        
            while True:
                if None not in cards_for_tech:
                    cards_for_tech.append( None )
                
                if len(cards_for_tech) <= 1:
                    break
                
                chosen_card_for_tech = self.players[self.state.player].pick(
                    Player.CARD_FOR_RESEARCH,
                    cards_for_tech,
                    rand, self.state.players[self.state.player], self.phase_start_state)
                self.log.append( { 'phase' : phase,
                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                   'target' : chosen_card_for_tech,
                                   'memo' : Game.L_SKILL_FOR_RESEARCH,
                                   'state' : self.state.to_json() } )
                if chosen_card_for_tech is None:
                    break
                self.phase_actions.append( ( self.state.player, Game.A_SKILL_RESEARCH,
                                             chosen_card_for_tech[1], self.state.tech[chosen_card_for_tech[0]] ) )
                self.state.drawpiles.return_card(chosen_card_for_tech[1], chosen_card_for_tech[3])
                del self.state.players[self.state.player].cards[chosen_card_for_tech[2]]
                
                idx = 0
                while idx < len(cards_for_tech):
                    if cards_for_tech[idx] is None:
                        idx += 1
                    elif cards_for_tech[idx][2] == chosen_card_for_tech[2]:
                        del cards_for_tech[idx]
                    else:
                        if cards_for_tech[idx][2] > chosen_card_for_tech[2]:
                            l = list(cards_for_tech[idx])
                            l[2] -= 1
                            cards_for_tech[idx] = tuple(l)
                        idx += 1
                
            ## funds for research
            to_fund = sorted(researching, key=lambda x:x.name)

            while True:
                if self.state.players[self.state.player].resources['$'] == 0:
                    break
                if None not in to_fund:
                    to_fund.append( None )

                if len(to_fund) <= 1:
                    break

                chosen_to_fund = self.players[self.state.player].pick(
                    Player.FUND_RESEARCH,
                    list(map(lambda x:None if x is None else x.name, to_fund)),
                    rand, self.state.players[self.state.player], self.phase_start_state)
                self.log.append( { 'phase' : phase,
                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                   'target' : chosen_to_fund,
                                   'memo' : Game.L_FUNDS_FOR_RESEARCH,
                                   'state' : self.state.to_json() } )
                if chosen_to_fund is None:
                    break
                self.phase_actions.append( ( self.state.player, Game.A_FUND_RESEARCH, self.state.tech[chosen_to_fund] ) )
                self.state.players[self.state.player].resources['$'] -= 1
                
                for idx, tech in enumerate(to_fund):
                    if tech is not None and tech.name == chosen_to_fund:
                        break
                del to_fund[idx]



  REFLECT

     EMPATHIZING
     
            succeeded = [ (p[2], p[3], idx, p[4], p[5])       for idx, p in enumerate(self.phase_actions)
                          if p[0] == self.state.player and p[1] == Game.A_SUCCESS_SKILL ]
            failed    = [ (p[0], p[2], p[3], idx, p[4], p[5]) for idx, p in enumerate(self.phase_actions)
                          if p[0] != self.state.player and p[1] == Game.A_FAILED_SKILL ]
            empath_pairs = list()
            for sproject, scard, sidx, sroll, svalue in succeeded:
                if sroll < 0: # joker
                    continue
                for player, fproject, fcard, fidx, froll, fvalue in failed:
                    if scard[0] == fcard[0] and sroll <= fvalue and froll <= svalue: # potential empath
                        empath_pairs.append( ( sproject.name, fproject.name, player,
                                               self.players[player].name, scard, fcard, sidx, fidx, sroll, froll ) )
            empath_pairs = sorted(empath_pairs)
            while True:
                if None not in empath_pairs:
                    empath_pairs.append( None )
                if len(empath_pairs) <= 1:
                    break
                empathize = self.players[self.state.player].pick(
                    Player.EMPATHIZE,
                    empath_pairs,
                    rand, self.state.players[self.state.player], self.phase_start_state)
                self.log.append( { 'phase' : phase,
                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                   'target' : empathize,
                                   'memo' : Game.L_EMPATHIZE,
                                   'state' : self.state.to_json() } )
                if empathize is None:
                    break
                l = list(self.phase_actions[empathize[6]])
                l[4] = empathize[9]
                self.phase_actions[empathize[6]] = tuple(l)
                l = list(self.phase_actions[empathize[7]])
                l[1] = Game.A_SUCCESS_SKILL
                l[4] = empathize[8]
                self.phase_actions[empathize[7]] = tuple(l)
                
                idx = 0
                while idx < len(empath_pairs):
                    if empath_pairs[idx] is None:
                        idx += 1
                    elif empath_pairs[idx][6] == empathize[6] or empath_pairs[idx][7] == empathize[7]:
                        del empath_pairs[idx]
                    else:
                        idx += 1


  END

    FINALIZING

                ## see if two players started researching the same tech and close the one with less resources applied to it
                tech_started = [ ( p[2], p[0] ) for p in self.phase_actions if p[1] == Game.A_START_RESEARCH ]
                counts = dict()
                for tech, player in tech_started:
                    counts[tech.name] = counts.get(tech.name, list()) + [ player ]
                for n, players in counts.items():
                    players = sorted(players)
                    for p in players[1:]:
                        self.state.players[p].tech.remove(n)
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][0],
                                           'target' : n,
                                           'memo' : Game.L_ABANDON_RESEARCH, 'args' : [ players[0] ],
                                           'state' : self.state.to_json() } )
                    self.state.tech[n]['player'] = players[0]

                ## see if any of the techs was researched and apply its actions
                for tech in self.state.tech.techs_for_status(TechTreeState.IN_PROGRESS):
                    # got skill and funds this turn?
                    skills = 0
                    funds  = 0
                    for act in self.phase_actions:
                        if act[1] == Game.A_SKILL_RESEARCH and act[2] == tech:
                            skills += 1
                        elif act[1] == Game.A_FUND_RESEARCH and act[2] == tech:
                            funds  += 1
                    if skills == 0 and funds == 0:
                        continue
                    if skills >= 1 and funds >= 1:
                        if skills >= 0:
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                               'target' : tech.name,
                                               'memo' : Game.L_OVERSKILLED, 'args' : [ skills - 1],
                                               'state' : self.state.to_json() } )
                        if funds >= 0:
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                               'target' : tech.name,
                                               'memo' : Game.L_OVERFUNDED, 'args' : [ funds - 1],
                                               'state' : self.state.to_json() } )
                        self.state.tech[tech.name]['missing_turns'] -= 1
                        
                        if self.state.tech[tech.name]['missing_turns'] > 0:
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                               'target' : tech.name,
                                               'memo' : Game.L_RESEARCH_CYCLE, 'args' : [ self.state.tech[tech.name]['missing_turns'] ],
                                               'state' : self.state.to_json() } )
                        else:
                            # finished!
                            self.state.tech.finish(tech.name)
                            tech_player = self.state.tech[tech.name]['player']
                            del self.state.players[tech_player].tech[self.state.players[tech_player].tech.index(tech.name)]
                            
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                               'target' : tech.name,
                                               'memo' : Game.L_RESEARCHED,
                                               'state' : self.state.to_json() } )

                            if tech.type_ == Tech.B:
                                # auto-protect, apply protection
                                node = self.game_def.graph.node_names[tech.node]
                                self.state.graph[node]['auto-protected'] = True
                                self.log.append( { 'phase' : phase,
                                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                                   'target' : node,
                                                   'memo' : Game.L_AUTO_PROTECTED,
                                                   'state' : self.state.to_json() } )
                                
                                if self.state.graph[node]['status'] == GraphState.STABLE:
                                    self.state.graph[node]['status'] = GraphState.PROTECTED
                                    self.log.append( { 'phase' : phase,
                                                       'step' : Game.STEPS_PER_PHASE[phase][0],
                                                       'target' : node,
                                                       'memo' : Game.L_PROTECTED,
                                                       'state' : self.state.to_json() } )
                    else:
                        if skills == 0:
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                               'target' : tech.name,
                                               'memo' : Game.L_FUNDED_NOT_SKILLED,
                                               'state' : self.state.to_json() } )
                        elif funds == 0:
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                               'target' : tech.name,
                                               'memo' : Game.L_SKILLED_NOT_FUNDED,
                                               'state' : self.state.to_json() } )
                            

                ## see if any of the projects had no action and should be discarded
                for project in self.state.projects.projects_for_status(ProjectState.IN_PROGRESS):
                    # got skill this turn?

                    skilled = False
                    for act in self.phase_actions:
                        if act[1] in set([Game.A_SUCCESS_SKILL, Game.A_FAILED_SKILL]) and act[2] == project:
                            skilled = True
                            break
                    if not skilled:
                        proj_player = self.state.projects[project.name]['player']
                        self.state.projects.abandon(project.name)
                        del self.state.players[proj_player].projects[self.state.players[proj_player].projects.index(project.name)]
                
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][0],
                                           'target' : project.name,
                                           'memo' : Game.L_PROJECT_ABANDONED,
                                           'state' : self.state.to_json() } )

                ## see if any of the projects was finished and apply its actions
                for project in self.state.projects.projects_for_status(ProjectState.IN_PROGRESS):
                    for act in self.phase_actions:
                        if act[1] == Game.A_SUCCESS_SKILL and act[2] == project:
                            missing = self.state.projects[project.name]['missing']
                            if act[3][0] not in missing:
                                self.log.append( { 'phase' : phase,
                                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                                   'target' : project.name,
                                                   'memo' : Game.L_PROJECT_OVERSKILLED, 'args' : [ act[3][0] ],
                                                   'state' : self.state.to_json() } )
                            else:
                                del missing[missing.index(act[3][0])]
                                self.state.projects[project.name]['missing'] = missing
                    if len(self.state.projects[project.name]['missing']) == 0:
                        # finished
                        proj_player = self.state.projects[project.name]['player']
                        self.state.projects.finish(project.name)
                        del self.state.players[proj_player].projects[self.state.players[proj_player].projects.index(project.name)]

                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][0],
                                           'target' : project.name,
                                           'memo' : Game.L_PROJECT_FINISHED,
                                           'state' : self.state.to_json() } )
                        
                        # apply effects
                        for fix in project.fixes:
                            fixn = self.game_def.graph.node_names[fix]
                            if self.state.graph[fixn]['status'] == GraphState.IN_CRISIS:
                                if self.state.graph[fixn]['auto-protected']:
                                    self.state.graph[fixn]['status'] = GraphState.PROTECTED
                                else:
                                    self.state.graph[fixn]['status'] = GraphState.STABLE
                                    
                                self.log.append( { 'phase' : phase,
                                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                                   'target' : fixn,
                                                   'memo' : Game.L_CRISIS_FIX_PROJECT, 'args' : [ project.name ],
                                                   'state' : self.state.to_json() } )
                                    
                        for trigger in project.triggers:
                            triggern = self.game_def.graph.node_names[trigger]
                            if self.state.graph[triggern]['status'] == GraphState.STABLE:
                                self.state.graph[triggern]['status'] = GraphState.IN_CRISIS
                                self.log.append( { 'phase' : phase,
                                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                                   'target' : triggern,
                                                   'memo' : Game.L_CRISIS_TRIGGERED, 'args' : [ project.name ],
                                                   'state' : self.state.to_json() } )
                            elif self.state.graph[triggern]['status'] == GraphState.PROTECTED:
                                self.state.graph[triggern]['status'] = GraphState.STABLE
                                self.log.append( { 'phase' : phase,
                                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                                   'target' : triggern,
                                                   'memo' : Game.L_PROT_LOSS_PROJECT, 'args' : [ project.name ],
                                                   'state' : self.state.to_json() } )
                            else: # in crisis, cascade
                                cascaded = self.cascade(trigger)
                                if cascaded:
                                    for trigger2 in sorted(cascaded, key=lambda x:self.game_def.graph.node_names[x]):
                                        trigger2n = self.game_def.graph.node_names[trigger2]
                                        if self.state.graph[trigger2n]['status'] == GraphState.STABLE:
                                            self.state.graph[trigger2n]['status'] = GraphState.IN_CRISIS
                                            self.log.append( { 'phase' : phase,
                                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                                               'target' : trigger2n,
                                                               'memo' : Game.L_CRISIS_TRIGGERED, 'args' : [ project.name ],
                                                               'state' : self.state.to_json() } )
                                        elif self.state.graph[trigger2n]['status'] == GraphState.PROTECTED:
                                            self.state.graph[trigger2n]['status'] = GraphState.STABLE
                                            self.log.append( { 'phase' : phase,
                                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                                               'target' : trigger2n,
                                                               'memo' : Game.L_PROT_LOSS_PROJECT, 'args' : [ project.name ],
                                                               'state' : self.state.to_json() } )
                                else:
                                    self.state.crisis_chips += 1
                                    self.log.append( { 'phase' : phase,
                                                       'step' : Game.STEPS_PER_PHASE[phase][0],
                                                       'target' : triggern,
                                                       'memo' : Game.L_CHIP_PROJECT, 'args' : [ project.name ],
                                                       'state' : self.state.to_json() } )

                ## TODO see if two identical policies got created and remove one
                
                ## see if any of the policies had no action and should be discarded
                for policy in self.state.policies.policies_for_status(PolicyState.IN_PROGRESS) + \
                    self.state.policies.policies_for_status(PolicyState.PASSED):
                    # got power this turn?

                    empowered = False
                    for act in self.phase_actions:
                        if act[1] == Game.A_EMPOWER_POLICY:
                            empowered = True
                            break
                    if not empowered:
                        pol_player = self.state.policies[policy.name]['player']
                        self.state.policies.abandon(policy.name)
                        del self.state.players[pol_player].policies[self.state.players[pol_player].policies.index(policy.name)]
                
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][0],
                                           'target' : policy.name,
                                           'memo' : Game.L_POLICY_ABANDONED,
                                           'state' : self.state.to_json() } )
                        
                ## see if any of the policies was passed
                for policy in self.state.policies.policies_for_status(PolicyState.IN_PROGRESS):
                    if self.state.policies[policy.name]['missing_power'] <= 0:

                        if self.state.policies[policy.name]['missing_power'] < 0:
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                               'target' : policy.name,
                                               'memo' : Game.L_POLICY_OVERPOWERED, 'args' : [ abs(self.state.policies[policy.name]['missing_power']) ],
                                               'state' : self.state.to_json() } )

                        self.state.policies.has_passed(policy.name)
                       
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][0],
                                           'target' : policy.name,
                                           'memo' : Game.L_POLICY_PASSED,
                                           'state' : self.state.to_json() } )
                
                ## see if any of the passed policies started and apply its actions
                for policy in self.state.policies.policies_for_status(PolicyState.PASSED):
                    self.state.policies[policy.name]['missing_turns'] -= 1
                    if self.state.policies[policy.name]['missing_turns'] == 0:
                        self.state.policies.finish(policy.name)
                        pol_player = self.state.policies[policy.name]['player']
                        del self.state.players[pol_player].policies[self.state.players[pol_player].policies.index(policy.name)]
                       
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][0],
                                           'target' : policy.name,
                                           'memo' : Game.L_POLICY_IN_ACTION,
                                           'state' : self.state.to_json() } )

                        for fix in policy.fixes:
                            fixn = self.game_def.graph.node_names[fix]
                            if self.state.graph[fixn]['status'] == GraphState.IN_CRISIS:
                                if self.state.graph[fixn]['auto-protected']:
                                    self.state.graph[fixn]['status'] = GraphState.PROTECTED
                                else:
                                    self.state.graph[fixn]['status'] = GraphState.STABLE
                                    
                                self.log.append( { 'phase' : phase,
                                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                                   'target' : fixn,
                                                   'memo' : Game.L_CRISIS_FIX_POLICY, 'args' : [ policy.name ],
                                                   'state' : self.state.to_json() } )
                                                                        
                        for protect in policy.protects:
                            protectn = self.game_def.graph.node_names[protect]
                            if self.state.graph[protectn]['status'] == GraphState.STABLE:
                                self.state.graph[protectn]['status'] = GraphState.PROTECTED
                                    
                                self.log.append( { 'phase' : phase,
                                                   'step' : Game.STEPS_PER_PHASE[phase][0],
                                                   'target' : protectn,
                                                   'memo' : Game.L_POLICY_PROTECT, 'args' : [ policy.name ],
                                                   'state' : self.state.to_json() } )
    CRISIS ROLLING

                ## add crisis chip for each category fully in crisis
                for cat, catid in Graph.CATEGORIES:
                    if len(self.state.graph.are_in_crisis(cat)) == len(self.game_def.graph.node_classes[catid]):
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][1],
                                           'target' : cat,
                                           'memo' : Game.L_CHIP_FULL_CAT,
                                           'state' : self.state.to_json() } )

                while self.state.crisis_chips and len(self.state.graph.are_in_crisis()) < len(self.game_def.graph):
                    ## roll a category, if the category is fully in crisis, add a crisis chip and roll again
                    catnum = self.roll_dice(1, self.state.player, 'crisis cat', rand, 1)
                    cat, catid = Graph.CATEGORIES[catnum - 1]
                    self.log.append( { 'phase' : phase,
                                       'step' : Game.STEPS_PER_PHASE[phase][1],
                                       'target' : cat,
                                       'memo' : Game.L_CRISIS_CAT,
                                       'state' : self.state.to_json() } )

                    if len(self.state.graph.are_in_crisis(cat)) == len(self.game_def.graph.node_classes[catid]):
                        self.log.append( { 'phase' : phase,
                                      'step' : Game.STEPS_PER_PHASE[phase][1],
                                      'target' : cat,
                                      'memo' : Game.L_CHIP_FULL_CAT,
                                      'state' : self.state.to_json() } )
                        continue

                    ## roll a node in category, if in crisis and all its descendants are in crisis, add a crisis chip and roll again
                    nodes = sorted(list(self.game_def.graph.node_classes[catid]))
                    dice = 1
                    if len(nodes) > 6:
                        dice += 1
                    nodenum = (self.roll_dice(dice, self.state.player, 'node in ' + cat, rand, 1) - 1) % len(nodes)
                    node = nodes[nodenum]
                    noden = self.game_def.graph.node_names[node]
                    if self.state.graph.is_saturated(noden):
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][1],
                                           'target' : noden,
                                           'memo' : Game.L_CHIP_SATURATED,
                                           'state' : self.state.to_json() } )
                        continue
                    
                    self.log.append( { 'phase' : phase,
                                       'step' : Game.STEPS_PER_PHASE[phase][1],
                                       'target' : noden,
                                       'memo' : Game.L_CRISIS_NODE,
                                       'state' : self.state.to_json() } )
                        
                    ## with a node in hand, roll crisis chips until either the roll is successful or all the crisis chips are exhausted
                    crisis_averted = True
                    while self.state.crisis_chips:
                        crisis_roll = self.roll_dice(2, self.state.player, 'crisis roll for ' + noden, rand, 1)
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][1],
                                           'target' : crisis_roll,
                                           'memo' : Game.L_CRISIS_ROLL, 'args' : [ noden ],
                                           'state' : self.state.to_json() } )
                        self.state.crisis_chips -= 1
                        if crisis_roll > 6:
                            crisis_averted = False
                            break

                    if crisis_averted:
                        self.log.append( { 'phase' : phase,
                                           'step' : Game.STEPS_PER_PHASE[phase][1],
                                           'target' : noden,
                                           'memo' : Game.L_CRISIS_AVERTED,
                                           'state' : self.state.to_json() } )
                    else:
                        ## if node was stable, set in crisis
                        if self.state.graph[noden]['status'] == GraphState.STABLE:
                            self.state.graph[noden]['status'] = GraphState.IN_CRISIS
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][1],
                                               'target' : noden,
                                               'memo' : Game.L_IN_CRISIS,
                                               'state' : self.state.to_json() } )
                            
                        ## if the node was protected, remove the protection
                        elif self.state.graph[noden]['status'] == GraphState.PROTECTED:
                            self.state.graph[noden]['status'] = GraphState.STABLE
                            self.log.append( { 'phase' : phase,
                                               'step' : Game.STEPS_PER_PHASE[phase][0],
                                               'target' : noden,
                                               'memo' : Game.L_PROT_LOSS,
                                               'state' : self.state.to_json() } )
                        ## if the node was in crisis, activate all the nodes reachable from it and further cascade as needed
                        else: 
                            cascaded = self.cascade(node)
                            for node2 in sorted(cascaded, key=lambda x:self.game_def.graph.node_names[x]):
                                node2n = self.game_def.graph.node_names[node2]
                                if self.state.graph[node2n]['status'] == GraphState.STABLE:
                                    self.state.graph[node2n]['status'] = GraphState.IN_CRISIS
                                    self.log.append( { 'phase' : phase,
                                                       'step' : Game.STEPS_PER_PHASE[phase][1],
                                                       'target' : node2n,
                                                       'memo' : Game.L_IN_CRISIS_CASCADE, 'args': [ noden ],
                                                       'state' : self.state.to_json() } )
                                elif self.state.graph[node2n]['status'] == GraphState.PROTECTED:
                                    self.state.graph[node2n]['status'] = GraphState.STABLE
                                    self.log.append( { 'phase' : phase,
                                                       'step' : Game.STEPS_PER_PHASE[phase][1],
                                                       'target' : node2n,
                                                       'memo' : Game.L_PROT_LOSS_CASCADE, 'args': [ noden ],
                                                       'state' : self.state.to_json() } )
                        

                    ## if there are more crisis chips, continue by selecting a new category
        return self.advance()





    def cascade(self, node, visited=None):
        "A node in crisis has been selected, deal with it. Returns the activated nodes."
        if visited is None:
            visited = list()
        if node in visited:
            return list()
        visited.append(node)
        result = list()
        outlinks = list(self.game_def.graph.outlinks[node])
        for outlink in outlinks:
            outlinkn = self.game_def.graph.node_names[outlink]
            if self.state.graph[outlinkn]['status'] != GraphState.IN_CRISIS:
                result.append(outlink)
        if result:
            return result
        # recurse
        for outlink in outlinks:
            result = result + self.cascade(outlink, list(visited))
            
        return result

